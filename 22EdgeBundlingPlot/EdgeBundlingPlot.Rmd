---
title: "Edge Bundling Plot"
author: "Defeng Bai Agricultural Genomics Institute at Shenzhen, Chinese Academy of Agricultural Sciences"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo=T, comment=NA, message=F, warning=F,
	fig.align="center", fig.width=5, fig.height=3, dpi=300)
```


### Edge Bunding图
Edge Bunding Plot

什么是Edge Bunding图？
What is Edge Bunding Plot?

参考：https://mp.weixin.qq.com/s/YYvb25LRzpZfB5pTIBSygw

Edge Bunding图是一种数据可视化方式，用于展示不同节点之间的联系。与普通的network的差别在于，它使用曲线来展示节点间的连接，而非直线，并会把相同趋势的曲线捆绑再一起，就像整理数据线的“环”。因此在关联较多的情况下，这一类可视化的方式可能有利于展现趋势的变化，而不会显得复杂而混乱。

Edge Bunding is a data visualization method used to show the connection between different nodes. The difference from ordinary networks is that it uses curves to show the connection between nodes instead of straight lines, and bundles curves with the same trend together, just like a "ring" to organize data lines. Therefore, in the case of many connections, this type of visualization method may be helpful in showing the change of trends without appearing complicated and chaotic.

Edge Bunding图除了环形，还有多种形式。在微生物组领域因为存在物种分类的信息，所以可能环形的排布方式能够呈现出更加直观的规律。

In addition to the circular form, the Edge Bunding diagram has many other forms. In the field of microbiome, because there is information on species classification, the circular arrangement may be able to present a more intuitive pattern.


### Edge Bunding图案例
Edge Bunding Plot Example

下图是来自于中山大学肿瘤防治中心Liu Na团队2022年发表于Jama Oncology（Qiao et al., 2022）上的一篇论文附件中的图。论文题目为：Association of Intratumoral Microbiota With Prognosis in Patients With Nasopharyngeal Carcinoma From 2 Hospitals in China。

Here is a figure from the supplementary materials of a paper published in JAMA Oncology in 2022 by Liu Na's team from the Sun Yat-sen University Cancer Center (Qiao et al., 2022). The paper is titled: "Association of Intratumoral Microbiota With Prognosis in Patients With Nasopharyngeal Carcinoma From 2 Hospitals in China."

![](EdgeBundingPlot01.jpg)

eFigure 17. Network analysis based on the Spearman correlation coefficient of the microbiome and the differentially immunologically expressed genes Green dots represent the microbes, hexagons represent the target genes (adjusted Benjamini-Hochberg P < .05), and black triangles in hexagons represent the immune function in which each gene is involved. The colour of the edge indicates the Spearman correlation of the microbial node and gene node. BCR indicates B-cell receptor; TCR, T- cell receptor.

eFigure 17. 基于微生物组和差异免疫表达基因的Spearman相关系数的网络分析。绿色圆点代表微生物，六边形代表目标基因（调整后的Benjamini-Hochberg P < .05），六边形内的黑色三角形代表每个基因所涉及的免疫功能。边的颜色表示微生物节点和基因节点的Spearman相关性。BCR表示B细胞受体；TCR表示T细胞受体。


**结果**：

We further annotated the differential immunological gene sets and analyzed their correlation with intratumoralbacteria inNPC.The results revealed that theexpression levels ofmostimmune-associatedgenes,suchasCXCL13,were negatively associatedwiththeabundanceofintratumoral bacteria such as Porphyromonas (eFigure 17 in Supplement 1).

我们进一步注释了差异免疫基因集，并分析了它们与鼻咽癌肿瘤内细菌的相关性。结果显示，大多数与免疫相关的基因（如CXCL13）的表达水平与肿瘤内细菌（如牙龈卟啉单胞菌）的丰度呈负相关（见补充材料1中的图eFigure 17）。


### Edge Bunding图R语言实战
Edge Bunding Plot using R software

这里实现两种类型对象数据进行Spearman相关性检验，并通过筛选符合条件的r和p值数据，利用Edge Bunding图展示正负相关性，通过连线的粗细展示相关性的强弱。
Here, we implement the Spearman correlation test for two types of object data, and by screening the r and p value data that meet the conditions, we use the Edge Bunding diagram to show the positive and negative correlations, and show the strength of the correlation by the thickness of the connecting line.

```{r EdgeBunding}
#1.安装并加载必要的库
#1. Install and load necessary libraries
#install.packages(c("psych", "magrittr", "reshape2", "dplyr", "readxl", "ggraph", "igraph", "tidyverse", "RColorBrewer"))

library(psych)
library(magrittr)
library(reshape2)
library(dplyr)
library(readxl)
library(ggraph)
library(igraph)
library(tidyverse)
library(RColorBrewer)

#2.加载数据
#2.Load data
data5 <- read.csv("data5_used.csv", row.names = 1, header = TRUE, check.names = FALSE)

#3.计算Spearman相关系数并调整p值
#3. Calculate the Spearman correlation coefficient and adjust the p-value
Cor_selected <- corr.test(data5, method="spearman", adjust="BH")
Cor <- as.data.frame(Cor_selected$r)

# 准备相关性数据
# Prepare correlation data
r.cor <- data.frame(Cor_selected$r)[1:36, 37:78]

#4.创建数据框并设置对角块为零
#4. Create a data frame and set the diagonal blocks to zero
data <- Cor %>% as.data.frame()
data[1:36, 1:36] <- 0
data[37:78, 37:78] <- 0

# 添加id列用于melt
# Add id column for melt
data$id <- colnames(data)

#5.准备用于绘图的相关性Connect数据
#5. Prepare the correlation data for plotting
# 定义相关性计算函数，这里只计算组件对象的相关性，不计算组内对象的相关性
# Define the correlation calculation function. Here, only the correlation of component objects is calculated, not the correlation of objects within the group.
calculate_correlations <- function(data, species_index, start_col, end_col) {
  rows <- end_col - start_col + 1
  Correlations <- data.frame(
    variable = character(length = rows),
    correlation = numeric(length = rows),
    p_adj = numeric(length = rows),
    stringsAsFactors = FALSE
  )
  for (i in 1:rows) {
    temp1 <- colnames(data5)[i + start_col - 1]
    temp2 <- corr.test(data5[, species_index], data5[, i + start_col - 1], method="spearman", adjust="BH")
    temp3 <- temp2$p.adj
    Correlations[i, 1] <- temp1
    Correlations[i, 2] <- temp2$r
    Correlations[i, 3] <- temp3
  }
  Correlations$species <- colnames(data5)[species_index]
  return(Correlations)
}

# 计算相关性
# Calculate correlation
start_col <- 37
end_col <- ncol(data5)
species_count <- 36
all_correlations <- list()

for (species_index in 1:species_count) {
  correlations <- calculate_correlations(data5, species_index, start_col, end_col)
  all_correlations[[species_index]] <- correlations
}

# 合并所有相关性数据
# Merge all related data
final_correlations <- do.call(rbind, all_correlations)

#筛选p_adj <= 0.05和r的绝对值>=0.4的数据
#Filter data with p_adj <= 0.05 and absolute value of r >= 0.4
final_correlations <- final_correlations[abs(final_correlations$correlation) >= 0.4 ,]
final_correlations <- final_correlations[final_correlations$p_adj <= 0.05 ,]

#data2 <- read.csv("species_gene_correlation_36S_42genes_selected.csv", row.names = 1, header = TRUE, check.names = FALSE)
data2 <- data.frame(from = final_correlations$species, to = final_correlations$variable, r = final_correlations$correlation, p_adj = final_correlations$p_adj)
cor.data2 <- data2 %>%
  data.frame() %>%
  mutate(
    linecolor = ifelse(r > 0, "positive", "negative"),
    linesize = abs(r)
  )
colnames(cor.data2) <- c("to", "from", "r", "FDR", "linecolor", "linesize")
connect_n <- cor.data2[, c(2, 1, 3, 5, 6)]

#6. 移除id列并创建分层边数据
#6. Remove the id column and create hierarchical edge data
data <- data %>% select(-id)

edge <- data.frame(from = 'Origin', to = colnames(data))
vertices <- data.frame(name = c('Origin', as.character(edge$to)))
colnames(vertices) <- "name"

# 对顶点进行分组
# Group the vertices
vertices$group <- "group"
vertices$group[1:37] <- "Species"
vertices$group[38:79] <- "Gene"

#7.计算角度并调整标签位置
#7. Calculate the angle and adjust the label position
all_leaves <- which(is.na(match(vertices$name, edge$from)))
nleaves <- length(all_leaves)
vertices$id[all_leaves] <- seq(1, nleaves)
vertices$angle <- 90 - 360 * vertices$id / nleaves
vertices$hjust <- ifelse(vertices$angle < -90, 1, 0)
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle + 180, vertices$angle)

#8.将连接与顶点匹配
#8. Match connections to vertices
from <- match(connect_n$from, vertices$name)
to <- match(connect_n$to, vertices$name)

connect1 <- connect_n[connect_n$r >= 0, ]
from1 <- match(connect1$from, vertices$name)
to1 <- match(connect1$to, vertices$name)
connect2 <- connect_n[connect_n$r < 0, ]
from2 <- match(connect2$from, vertices$name)
to2 <- match(connect2$to, vertices$name)

#9.创建图对象并生成图
#9. Create a graph object and generate a graph
mygraph <- graph_from_data_frame(edge, vertices = vertices)

# 生成图
# Generate graph
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) +
  geom_conn_bundle(data = get_con(from = from, to = to), 
                   aes(edge_width = rep(connect_n$linesize, 3), edge_colour = rep(connect_n$linecolor, 3), edge_alpha = 0.8),
                   tension = 0.8) +
  geom_node_point(aes(filter = leaf, x = 1.05 * x, y = 1.05 * y, size = 5, color = group, alpha = 0.2)) +
  geom_node_text(aes(filter = leaf, x = 1.1 * x, y = 1.1 * y, label = name, angle = angle, hjust = hjust, color = group), size = 2.5) +
  scale_edge_color_manual(values = c("#BA55D3", "#CCEEFF")) +
  scale_edge_width_continuous(range = c(0.2,1.6)) +
  scale_size_continuous(range = c(0.1, 1.5)) +
  scale_color_manual(values = rep(c('#6A5ACD', '#189078', '#54278f'), 30)) +
  theme_void() +
  theme(plot.margin = unit(c(0, 0, 0, 0), 'cm')) +
  coord_fixed() +
  expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2))

#10.保存图像
#10. Save the image
ggsave(filename = 'EdgeBundingPlot01.pdf', dpi = 300)

```

